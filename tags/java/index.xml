<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Abhigyan Kishor</title>
    <link>https://ak1909552.github.io/site-stuff/tags/java/</link>
    <description>Recent content in java on Abhigyan Kishor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 05 May 2022 15:39:24 +0300</lastBuildDate><atom:link href="https://ak1909552.github.io/site-stuff/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 225</title>
      <link>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-225/</link>
      <pubDate>Thu, 05 May 2022 15:39:24 +0300</pubDate>
      
      <guid>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-225/</guid>
      <description>Leetcode 255: Implementing Stacks Using Queues Head on over here to try the problem for yourself.
The solution talks about using 2 queues, which frankly I don&amp;rsquo;t understand :&amp;rsquo;). I used a single queue to implement this problem.
Algorithm The goal is to implement a stack using the basic queue features provided such as push(), peek() and pop(). The easiest way to implement this is by inserting elements in reverse order.</description>
    </item>
    
    <item>
      <title>Leetcode 1769</title>
      <link>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-1769/</link>
      <pubDate>Wed, 04 May 2022 14:27:17 +0300</pubDate>
      
      <guid>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-1769/</guid>
      <description>Leetcode 1769: Max Number of K-sum Pairs Head on over here to try the problem for yourself.
This is a varaition of the famous two-sum problem that we have all struggled with :)
Algorithm &amp;amp; Code The slower O(n) The goal is the count unique pairs of integers that sum up to given k. For this, we create a hashmap that stores unique values of the integers. Then we go over the keySet() and update the count according to the following rules:</description>
    </item>
    
    <item>
      <title>Leetcode 581</title>
      <link>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-581/</link>
      <pubDate>Tue, 03 May 2022 17:10:04 +0300</pubDate>
      
      <guid>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-581/</guid>
      <description>Leetcode 581: Shortest Unsorted Continuous Subarray Head on over here to try the problem for yourself.
I solved this problem using a two-pointer method.
Algorithm The goal is to find the points where the array becomes unsorted. We use two loops, one to find the end of the unsorted sub-array and another to find the start of the unsorted sub-array. start = end = -1 as a way to check if they were updated or not during the loops.</description>
    </item>
    
    <item>
      <title>Leetcode 905</title>
      <link>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-905/</link>
      <pubDate>Mon, 02 May 2022 11:36:29 +0300</pubDate>
      
      <guid>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-905/</guid>
      <description>Leetcode 905: Sort Array by Parity Head on over here to try the problem for yourself.
I attempted a two-pointer approach to try and solve it.
Algorithm The goal is to try to return the parity array in one pass. For this reason, I create a new array result[] and two pointers, evenPtr, pointing to the start of result[] and oddPtr, pointing to the end of result[]. Now I loop over the initial array.</description>
    </item>
    
    <item>
      <title>Leetcode 844</title>
      <link>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-844/</link>
      <pubDate>Sun, 01 May 2022 17:55:32 +0300</pubDate>
      
      <guid>https://ak1909552.github.io/site-stuff/posts/2022/05/leetcode-844/</guid>
      <description>Leetcode 844: Backspace String Compare Head on over here to try the problem for yourself.
There are a few ways discussed in the solutions. I will try to explain the two-pointer method.
Algorithm The goal is to try to build the resultant string in one pass. For this reason, we will iterate over the string backwards. If we encounter #, we simply skip the first valid character that follows. Ofcourse, the caveats are considering more backspaces (#) than actual words, in which case we simply get an empty string.</description>
    </item>
    
  </channel>
</rss>
